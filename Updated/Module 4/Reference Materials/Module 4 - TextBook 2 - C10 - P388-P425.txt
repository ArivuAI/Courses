Chapter 10

Sequence Modeling: Recurrent
and Recursive Nets

Recurrent neural networks or RNNs (Rumelhart et al., 1986a) are a family of
neural networks for processing sequential data. Much as a convolutional network
is a neural network that is specialized for processing a grid of values X such as
an image, a recurrent neural network is a neural network that is specialized for
processing a sequence of values gi) .. ae), Just as convolutional networks
can readily scale to images with large width and height, and some convolutional
networks can process images of variable size, recurrent networks can scale to much
longer sequences than would be practical for networks without sequence-based
specialization. Most recurrent networks can also process sequences of variable
length.

To go from multi-layer networks to recurrent networks, we need to take advan-
tage of one of the early ideas found in machine learning and statistical models of
the 1980s: sharing parameters across different parts of a model. Parameter sharing
makes it possible to extend and apply the model to examples of different forms
(different lengths, here) and generalize across them. If we had separate parameters
for each value of the time index, we could not generalize to sequence lengths not
seen during training, nor share statistical strength across different sequence lengths
and across different positions in time. Such sharing is particularly important when
a specific piece of information can occur at multiple positions within the sequence.
For example, consider the two sentences “I went to Nepal in 2009” and “In 2009,
I went to Nepal.” If we ask a machine learning model to read each sentence and
extract the year in which the narrator went to Nepal, we would like it to recognize
the year 2009 as the relevant piece of information, whether it appears in the sixth

373
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

word or the second word of the sentence. Suppose that we trained a feedforward
network that processes sentences of fixed length. A traditional fully connected
feedforward network would have separate parameters for each input feature, so it
would need to learn all of the rules of the language separately at each position in
the sentence. By comparison, a recurrent neural network shares the same weights
across several time steps.

A related idea is the use of convolution across a 1-D temporal sequence. This
convolutional approach is the basis for time-delay neural networks (Lang and
Hinton, 1988; Waibel et al., 1989; Lang e# al., 1990). The convolution operation
allows a network to share parameters across time, but is shallow. The output
of convolution is a sequence where each member of the output is a function of
a small number of neighboring members of the input. The idea of parameter
sharing manifests in the application of the same convolution kernel at each time
step. Recurrent networks share parameters in a different way. Each member of the
output is a function of the previous members of the output. Each member of the
output is produced using the same update rule applied to the previous outputs.
This recurrent formulation results in the sharing of parameters through a very
deep computational graph.

For the simplicity of exposition, we refer to RNNs as operating on a sequence
that contains vectors 2“) with the time step index ¢ ranging from 1 to r. In
practice, recurrent networks usually operate on minibatches of such sequences,
with a different sequence length 7 for each member of the minibatch. We have
omitted the minibatch indices to simplify notation. Moreover, the time step index
need not literally refer to the passage of time in the real world, but only to the
position in the sequence. RNNs may also be applied in two dimensions across
spatial data such as images, and even when applied to data involving time, the
network may have connections that go backwards in time, provided that the entire
sequence is observed before it is provided to the network.

This chapter extends the idea of a computational graph to include cycles. These
cycles represent the influence of the present value of a variable on its own value
at a future time step. Such computational graphs allow us to define recurrent
neural networks. We then describe many different ways to construct, train, and
use recurrent neural networks.

For more information on recurrent neural networks than is available in this
chapter, we refer the reader to the textbook of Graves (2012).

374
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

10.1 Unfolding Computational Graphs

A computational graph is a way to formalize the structure of a set of computations,
such as those involved in mapping inputs and parameters to outputs and loss.
Please refer to Sec. 6.5.1 for a general introduction. In this section we explain
the idea of unfolding a recursive or recurrent computation into a computational
graph that has a repetitive structure, typically corresponding to a chain of events.
Unfolding this graph results in the sharing of parameters across a deep network
structure.

For example, consider the classical form of a dynamical system:
s) = f(s; 8), (10.1)

where s ) is called the state of the system.

Eq. 10.1 is recurrent because the definition of s at time t refers back to the
same definition at time t — 1.

For a finite number of time steps 7, the graph can be unfolded by applying the
definition 7 — 1 times. For example, if we unfold Eq. 10.1 for 7 = 3 time steps, we
obtain

g) =f(s®), 6) (10.2)
=f (f(s; 8); 6) (10.3)

Unfolding the equation by repeatedly applying the definition in this way has
yielded an expression that does not involve recurrence. Such an expression can
now be represented by a traditional directed acyclic computational graph. The
unfolded computational graph of Eq. 10.1 and Eq. 10.3 is illustrated in Fig. 10.1.

rea Ora rae >

Figure 10.1: The classical dynamical system described by Eq. 10.1, illustrated as an
unfolded computational graph. Each node represents the state at some time? and the
function f maps the state at t to the state at t+ 1. The same parameters (the same value
of @ used to parametrize f) are used for all time steps.

As another example, let us consider a dynamical system driven by an external
signal ge,

s = f(s) a, 9), (10.4)
375
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

where we see that the state now contains information about the whole past sequence.

Recurrent neural networks can be built in many different ways. Much as
almost any function can be considered a feedforward neural network, essentially
any function involving recurrence can be considered a recurrent neural network.

Many recurrent neural networks use Eq. 10.5 or a similar equation to define
the values of their hidden units. To indicate that the state is the hidden units of
the network, we now rewrite Eq. 10.4 using the variable h to represent the state:

n® = f(r), 2, 9), (10.5)

illustrated in Fig. 10.2, typical RNNs will add extra architectural features such as
output layers that read information out of the state h to make predictions.

When the recurrent network is trained to perform a task that requires predicting
the future from the past, the network typically learns to use h® as a kind of lossy
summary of the task-relevant aspects of the past sequence of inputs up tot. This
summary is in general necessarily lossy, since it maps an arbitrary length sequence
(2 , 2D, a2)... 2), 2) to a fixed length vector h®. Depending on the
training criterion, this summary might selectively keep some aspects of the past
sequence with more precision than other aspects. For example, if the RNN is used
in statistical language modeling, typically to predict the next word given previous
words, it may not be necessary to store all of the information in the input sequence
up to time t, but rather only enough information to predict the rest of the sentence.
The most demanding situation is when we ask h) to be rich enough to allow
one to approximately recover the input sequence, as in autoencoder frameworks

(Chapter 14).
i"
| " Tobe ( (0 \
—p‘.-- f

f Unfold

~
‘\

s fey

al

is

ov
oY

Figure 10.2: A recurrent network with no outputs. This recurrent network just processes
information from the input x by incorporating it into the state h that is passed forward
through time. (Left) Circuit diagram. The black square indicates a delay of 1 time step.
(Right) The same network seen as an unfolded computational graph, where each node is
now associated with one particular time instance.

Eq. 10.5 can be drawn in two different ways. One way to draw the RNN is
with a diagram containing one node for every component that might exist in a

376
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

physical implementation of the model, such as a biological neural network. In
this view, the network defines a circuit that operates in real time, with physical
parts whose current state can influence their future state, as in the left of Fig. 10.2.
Throughout this chapter, we use a black square in a circuit diagram to indicate
that an interaction takes place with a delay of 1 time step, from the state at time
# to the state at time {+ 1. The other way to draw the RNN is as an unfolded
computational graph, in which each component is represented by many different
variables, with one variable per time step, representing the state of the component
at that point in time. Each variable for each time step is drawn as a separate node
of the computational graph, as in the right of Fig. 10.2. What we call unfolding is
the operation that maps a circuit as in the left side of the figure to a computational
graph with repeated pieces as in the right side. The unfolded graph now has a size
that depends on the sequence length.

We can represent the unfolded recurrence after t steps with a function g“):

=f(ht-Y, 2, @) (10.7)
The function g takes the whole past sequence (a4), etl) glt-2) 2. e(?), a (1))

as input and produces the current state, but the unfolded recurrent structure
allows us to factorize g) into repeated application of a function f. The unfolding
process thus introduces two major advantages:

1. Regardless of the sequence length, the learned model always has the same
input size, because it is specified in terms of transition from one state to
another state, rather than specified in terms of a variable-length history of
states.

2. It is possible to use the same transition function f with the same parameters
at every time step.

These two factors make it possible to learn a single model f that operates on
all time steps and all sequence lengths, rather than needing to learn a separate
model g® for all possible time steps. Learning a single, shared model allows
generalization to sequence lengths that did not appear in the training set, and
allows the model to be estimated with far fewer training examples than would be
required without parameter sharing.

Both the recurrent graph and the unrolled graph have their uses. The recurrent
graph is succinct. The unfolded graph provides an explicit description of which
computations to perform. The unfolded graph also helps to illustrate the idea of

377
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

information flow forward in time (computing outputs and losses) and backward

in time (computing gradients) by explicitly showing the path along which this
information flows.

10.2 Recurrent Neural Networks

Armed with the graph unrolling and parameter sharing ideas of Sec. 10.1, we can
design a wide variety of recurrent neural networks.

gg
©)
Q at
CL EER OREA
@)

Figure 10.3: The computational graph to compute the training loss of a recurrent network
that maps an input sequence of x values to a corresponding sequence of output o values.
A loss L measures how far each ois from the corresponding training target y. When using
softmax outputs, we assume o is the unnormalized log probabilities. The loss ZL internally
computes 9 = softmax(o) and compares this to the target y. The RNN has input to hidden
connections parametrized by a weight matrix U, hidden-to-hidden recurrent connections
parametrized by a weight matrix W, and hidden-to-output connections parametrized by
a weight matrix V. Eq. 10.8 defines forward propagation in this model. (Left) The RNN
and its loss drawn with recurrent connections. (Right) The same seen as an time-unfolded
computational graph, where each node is now associated with one particular time instance.

Od oe

Some examples of important design patterns for recurrent neural networks
include the following:

e Recurrent networks that produce an output at each time step and have

378
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

recurrent connections between hidden units, illustrated in Fig. 10.3.

e Recurrent networks that produce an output at each time step and have
recurrent connections only from the output at one time step to the hidden
units at the next time step, illustrated in Fig. 10.4

e Recurrent networks with recurrent connections between hidden units, that
read an entire sequence and then produce a single output, illustrated in Fig.
10.5.

Fig. 10.3 is a reasonably representative example that we return to throughout
most of the chapter.

The recurrent neural network of Fig. 10.3 and Eq. 10.8 is universal in the
sense that any function computable by a Turing machine can be computed by such
a recurrent network of a finite size. The output can be read from the RNN after
a number of time steps that is asymptotically linear in the number of time steps
used by the Turing machine and asymptotically linear in the length of the input
(Siegelmann and Sontag, 1991; Siegelmann, 1995; Siegelmann and Sontag, 1995;
Hyotyniemi, 1996). The functions computable by a Turing machine are discrete,
so these results regard exact implementation of the function, not approximations.
The RNN, when used as a Turing machine, takes a binary sequence as input and its
outputs must be discretized to provide a binary output. It is possible to compute all
functions in this setting using a single specific RNN of finite size (Siegelmann and
Sontag (1995) use 886 units). The “input” of the Turing machine is a specification
of the function to be computed, so the same network that simulates this Turing
machine is sufficient for all problems. The theoretical RNN used for the proof
can simulate an unbounded stack by representing its activations and weights with
rational numbers of unbounded precision.

We now develop the forward propagation equations for the RNN depicted in
Fig. 10.3. The figure does not specify the choice of activation function for the
hidden units. Here we assume the hyperbolic tangent activation function. Also,
the figure does not specify exactly what form the output and loss function take.
Here we assume that the output is discrete, as if the RNN is used to predict words
or characters. A natural way to represent discrete variables is to regard the output
o as giving the unnormalized log probabilities of each possible value of the discrete
variable. We can then apply the softmax operation as a post-processing step to
obtain a vector y of normalized probabilities over the output. Forward propagation
begins with a specification of the initial state h©). Then, for each time step from
t=1tot=7, we apply the following update equations:

a = b+ wh) +02 (10.8)
379
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

@)
‘. w
Vv ‘.
w re
a

U

Figure 10.4: An RNN whose only recurrence is the feedback connection from the output
to the hidden layer. At each time stept, the input is x, the hidden layer activations are

h®), the outputs are o, the targets are y) and the loss is L®. (Left) Circuit diagram.
(Right) Unfolded computational graph. Such an RNN is less powerful (can express a
smaller set of functions) than those in the family represented by Fig. 10.3. The RNN
in Fig. 10.3 can choose to put any information it wants about the past into its hidden
representation h and transmit h to the future. The RNN in this figure is trained to
put a specific output value intoo, and o is the only information it is allowed to send
to the future. There are no direct connections from h going forward. The previous h

is connected to the present only indirectly, via the predictions it was used to produce.
Unless o is very high-dimensional and rich, it will usually lack important information
from the past. This makes the RNN in this figure less powerful, but it may be easier to
train because each time step can be trained in isolation from the others, allowing greater
parallelization during training, as described in Sec. 10.2.1.

380
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

h® = tanh(a) (10.9)
o) = c+Vh (10.10)
yg = softmax(o) (10.11)

where the parameters are the bias vectors b and c along with the weight matrices
U, V and W, respectively for input-to-hidden, hidden-to-output and hidden-to-
hidden connections. This is an example of a recurrent network that maps an
input sequence to an output sequence of the same length. The total loss for a
given sequence of x values paired with a sequence of y values would then be just
the sum of the losses over all the time steps. For example, if L® is the negative
log-likelihood of y) given a), eeey att) then

L (fo, 2 OF, (yO, yO i) (10.12)
=S> Lo (10.13)
t
=—_ Slog Pmodel (y | {e, tae ,e}) , (10.14)
t

where Pmodel (y | {a , wo, ol) }) is given by reading the entry for y from the
model’s output vector yg. Computing the gradient of this loss function with
respect to the parameters is an expensive operation. The gradient computation
involves performing a forward propagation pass moving left to right through our
illustration of the unrolled graph in Fig. 10.3, followed by a backward propagation
pass moving right to left through the graph. The runtime is O(7) and cannot be
reduced by parallelization because the forward propagation graph is inherently
sequential; each time step may only be computed after the previous one. States
computed in the forward pass must be stored until they are reused during the
backward pass, so the memory cost is also O(7). The back-propagation algorithm
applied to the unrolled graph with O(r) cost is called back-propagation through
time or BPTT and is discussed further Sec. 10.2.2. The network with recurrence
between hidden units is thus very powerful but also expensive to train. Is there an
alternative?

10.2.1 Teacher Forcing and Networks with Output Recurrence

The network with recurrent connections only from the output at one time step to
the hidden units at the next time step (shown in Fig. 10.4) is strictly less powerful
because it lacks hidden-to-hidden recurrent connections. For example, it cannot
simulate a universal Turing machine. Because this network lacks hidden-to-hidden

381
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

recurrence, it requires that the output units capture all of the information about
the past that the network will use to predict the future. Because the output units
are explicitly trained to match the training set targets, they are unlikely to capture
the necessary information about the past history of the input, unless the user
knows how to describe the full state of the system and provides it as part of the
training set targets. The advantage of eliminating hidden-to-hidden recurrence
is that, for any loss function based on comparing the prediction at time ¢ to the
training target at time f, all the time steps are decoupled. Training can thus be
parallelized, with the gradient for each step ¢ computed in isolation. There is no
need to compute the output for the previous time step first, because the training
set provides the ideal value of that output.

V

ON oN
to... Lo Pei. Lk
\ ‘WwW ‘ WwW

U U vA

oN

t gl)

\ /

ed

Figure 10.5: Time-unfolded recurrent neural network with a single output at the end
of the sequence. Such a network can be used to summarize a sequence and produce a
fixed-size representation used as input for further processing. There might be a target
right at the end (as depicted here) or the gradient on the output o can be obtained by
back-propagating from further downstream modules.

U

Models that have recurrent connections from their outputs leading back into
the model may be trained with teacher forcing. Teacher forcing is a procedure
that emerges from the maximum likelihood criterion, in which during training the
model receives the ground truth output y as input at time t+ 1. We can see
this by examining a sequence with two time steps. The conditional maximum
likelihood criterion is

logp (y,y® | 2°), @) (10.15)

382
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

Train time Test time

Figure 10.6: Ilustration of teacher forcing. Teacher forcing is a training technique that is
applicable to RNNs that have connections from their output to their hidden states at the
next time step. (Left) At train time, we feed the correct outputy drawn from the train
set as input to h+)), (Right) When the model is deployed, the true output is generally
not known. In this case, we approximate the correct output yf with the model’s output
of), and feed the output back into the model.

383
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

=log p(y) ly, 2), x(?)) + log p (y® | a (4), 2) (10.16)

In this example, we see that at timet = 2, the model is trained to maximize the
conditional probability of y@) given both the # sequence so far and the previous y
value from the training set. Maximum likelihood thus specifies that during training,
rather than feeding the model’s own output back into itself, these connections
should be fed with the target values specifying what the correct output should be.
This is illustrated in Fig. 10.6.

We originally motivated teacher forcing as allowing us to avoid back-propagation
through time in models that lack hidden-to-hidden connections. Teacher forcing
may still be applied to models that have hidden-to-hidden connections so long as
they have connections from the output at one time step to values computed in the
next time step. However, as soon as the hidden units become a function of earlier
time steps, the BPTT algorithm is necessary. Some models may thus be trained
with both teacher forcing and BPTT.

The disadvantage of strict teacher forcing arises if the network is going to be
later used in an open-loop mode, with the network outputs (or samples from the
output distribution) fed back as input. In this case, the kind of inputs that the
network sees during training could be quite different from the kind of inputs that
it will see at test time. One way to mitigate this problem is to train with both
teacher-forced inputs and with free-running inputs, for example by predicting the
correct target a number of steps in the future through the unfolded recurrent
output-to-input paths. In this way, the network can learn to take into account
input conditions (such as those it generates itself in the free-running mode) not
seen during training and how to map the state back towards one that will make
the network generate proper outputs after a few steps. Another approach (Bengio
et al., 2015b) to mitigate the gap between the inputs seen at train time and the
inputs seen at test time randomly chooses to use generated values or actual data
values as input. This approach exploits a curriculum learning strategy to gradually
use more of the generated values as input.

10.2.2. Computing the Gradient in a Recurrent Neural Network

Computing the gradient through a recurrent neural network is straightforward.
One simply applies the generalized back-propagation algorithm of Sec. 6.5.6 to the
unrolled computational graph. No specialized algorithms are necessary. The use
of back-propagation on the unrolled graph is called the back-propagation through
time (BPTT) algorithm. Gradients obtained by back-propagation may then be
used with any general-purpose gradient-based techniques to train an RNN.

384
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

To gain some intuition for how the BPTT algorithm behaves, we provide an
example of how to compute gradients by BPTT for the RNN equations above
(Eq. 10.8 and Eq. 10.12). The nodes of our computational graph include the
parameters U, V, W, 6 and c as well as the sequence of nodes indexed by ¢ for
x), h®, o and L®. For each node N we need to compute the gradient VuL
recursively, based on the gradient computed at nodes that follow it in the graph.
We start the recursion with the nodes immediately preceding the final loss

aL _,
aL® ~

(10.17)

In this derivation we assume that the outputs o) are used as the argument to the
softmax function to obtain the vector y of probabilities over the output. We also
assume that the loss is the negative log-likelihood of the true target y) given the
input so far. The gradient V,@2Z on the outputs at time step ¢, for all 7,¢, is as
follows:

OL _ OL aL®) _ a(t)
ao) AL® a ~~

(Vy L); = 1, 40 (10.18)

We work our way backwards, starting from the end of the sequence. At the final
time step 7, h™ only has 07) as a descendent, so its gradient is simple:

VanLb= VIVomL.- (10.19)

We can then iterate backwards in time to back-propagate gradients through time,
from t= 7 — 1 down to t= 1, noting that ne (for t < 7) has as descendents both
o and h&t). Its gradient is thus given by

ant+t)\ " ao) \"
Va) L= Oh® (Vaal) + oh® (Vow) (10.20)

2
= W" (V,e+nL) diag (1 - (at) ) ) +VT(VypL) (10.21)

where diag (1 - (net) )”) indicates the diagonal matrix containing the elements

1- (net) Y. This is the Jacobian of the hyperbolic tangent associated with the
hidden unit 7 at time ¢+ 1.

Once the gradients on the internal nodes of the computational graph are
obtained, we can obtain the gradients on the parameter nodes. Because the
parameters are shared across many time steps, we must take some care when
denoting calculus operations involving these variables. The equations we wish to

385
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

implement use the bprop method of Sec. 6.5.6, that computes the contribution
of a single edge in the computational graph to the gradient. However, the Vwf
operator used in calculus takes into account the contribution of W to the value
of f due to all edges in the computational graph. To resolve this ambiguity, we
introduce dummy variables W™ that are defined to be copies of W but with each
W') used only at time step t. We may then use V ww to denote the contribution
of the weights at time step ¢ to the gradient.

Using this notation, the gradient on the remaining parameters is given by:

dol) t
Veb = >) Ge | Vooh= dV owl (10.22)
t Cc t
an)" wy
Vel = » apm | Veoh = > diag (1 - ( ) ) Waco (10-28)
t
Vvl = et 2) Ye of = = 2 (Vo wL)ho" (10.24)

Vwl = Ey(; a Vwwh (10.25)
= 5 (1 — (n® ) *) (noob) ne)" (10.26)
_ (t)
VuL = =x (24) Vyuwh; (10.27)
2
= Yodiag (: — (n®) ) not)" (10.28)
t

We do not need to compute the gradient with respect to « for training because
it does not have any parameters as ancestors in the computational graph defining
the loss.

10.2.3. Recurrent Networks as Directed Graphical Models

In the example recurrent network we have developed so far, the losses L') were
cross-entropies between training targets y) and outputs o). As with a feedforward
network, it is in principle possible to use almost any loss with a recurrent network.
The loss should be chosen based on the task. As with a feedforward network, we
usually wish to interpret the output of the RNN as a probability distribution, and

386
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

we usually use the cross-entropy associated with that distribution to define the loss.
Mean squared error is the cross-entropy loss associated with an output distribution
that is a unit Gaussian, for example, just as with a feedforward network.

When we use a predictive log-likelihood training objective, such as Eq. 10.12, we
train the RNN to estimate the conditional distribution of the next sequence element
y™ given the past inputs. This may mean that we maximize the log-likelihood

log p(y | 2,..., 2), (10.29)

or, if the model includes connections from the output at one time step to the next

time step,
log p(y |a™,..., 028, yM,..., yD). (10.30)

Decomposing the joint probability over the sequence of y values as a series of
one-step probabilistic predictions is one way to capture the full joint distribution
across the whole sequence. When we do not feed past y values as inputs that
condition the next step prediction, the directed graphical model contains no edges
from any y® in the past to the current y®. In this case, the outputs y are
conditionally independent given the sequence of a values. When we do feed the
actual y values (not their prediction, but the actual observed or generated values)
back into the network, the directed graphical model contains edges from all y@
values in the past to the current ;f*) value.

Figure 10.7: Fully connected graphical model for a sequencey™), y@),...,y,...: every
past observation y) may influence the conditional distribution of some y“) (for ¢ > 4),
given the previous values. Parametrizing the graphical model directly according to this
graph (as in Eq. 10.6) might be very inefficient, with an ever growing number of inputs
and parameters for each element of the sequence. RNNs obtain the same full connectivity
but efficient parametrization, as illustrated in Fig. 10.8.

387
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

As a simple example, let us consider the case where the RNN models only a
sequence of scalar random variables Y = fy), eng yO}, with no additional inputs
x. The input at time step ¢ is simply the output at time step t—1. The RNN then
defines a directed graphical model over the y variables. We parametrize the joint
distribution of these observations using the chain rule (Eq. 3.6) for conditional
probabilities:

P(Y) = P(y™,...,y¥) =] Piy® |y*9,y*,...,y) (10.81)
t=1

where the right-hand side of the bar is empty for t = 1, of course. Hence the

negative log-likelihood of a set of values {y, wee yO} according to such a model
is
L= > L® (10.32)
t
where
L© = — log Py = y® | yO), yO, y). (10.33)

Figure 10.8: Introducing the state variable in the graphical model of the RNN, even
though it is a deterministic function of its inputs, helps to see how we can obtain a very
efficient parametrization, based on Eq. 10.5. Every stage in the sequence (forh) and
y) involves the same structure (the same number of inputs for each node) and can share
the same parameters with the other stages.

The edges in a graphical model indicate which variables depend directly on other
variables. Many graphical models aim to achieve statistical and computational
efficiency by omitting edges that do not correspond to strong interactions. For
example, it is common to make the Markov assumption that the graphical model
should only contain edges from {y-4),...,y“-)} to y®, rather than containing
edges from the entire past history. However, in some cases, we believe that all past
inputs should have an influence on the next element of the sequence. RNNs are
useful when we believe that the distribution over y“) may depend on a value of y
from the distant past in a way that is not captured by the effect of y® on y@—),

388
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

One way to interpret an RNN as a graphical model is to view the RNN as
defining a graphical model whose structure is the complete graph, able to represent
direct dependencies between any pair of y values. The graphical model over the
y values with the complete graph structure is shown in Fig. 10.7. The complete
graph interpretation of the RNN is based on ignoring the hidden units h® by
marginalizing them out of the model.

It is more interesting to consider the graphical model structure of RNNs that
results from regarding the hidden units hn) as random variables. ! Including the
hidden units in the graphical model reveals that the RNN provides a very efficient
parametrization of the joint distribution over the observations. Suppose that we
represented an arbitrary joint distribution over discrete values with a tabular
representation—an array containing a separate entry for each possible assignment
of values, with the value of that entry giving the probability of that assignment
occurring. If y can take on é& different values, the tabular representation would
have O(k") parameters. By comparison, due to parameter sharing, the number
of parameters in the RNN is O(1) as a function of sequence length. The number
of parameters in the RNN may be adjusted to control model capacity but is not
forced to scale with sequence length. Eq. 10.5 shows that the RNN parametrizes
long-term relationships between variables efficiently, using recurrent applications
of the same function f and same parameters @ at each time step. Fig. 10.8
illustrates the graphical model interpretation. Incorporating the h® nodes in
the graphical model decouples the past and the future, acting as an intermediate
quantity between them. A variable y) in the distant past may influence a variable
y) via its effect onh. The structure of this graph shows that the model can be
efficiently parametrized by using the same conditional probability distributions at
each time step, and that when the variables are all observed, the probability of the
joint assignment of all variables can be evaluated efficiently.

Even with the efficient parametrization of the graphical model, some operations
remain computationally challenging. For example, it is difficult to predict missing
values in the middle of the sequence.

The price recurrent networks pay for their reduced number of parameters is
that optimizing the parameters may be difficult.

The parameter sharing used in recurrent networks relies on the assumption
that the same parameters can be used for different time steps. Equivalently, the
assumption is that the conditional probability distribution over the variables at

1The conditional distribution over these variables given their parents is deterministic. This is
perfectly legitimate, though it is somewhat rare to design a graphical model with such deterministic
hidden units.

389
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

time t+ 1 given the variables at time t is stationary, meaning that the relationship
between the previous time step and the next time step does not depend on¢. In
principle, it would be possible to use ¢ as an extra input at each time step and let
the learner discover any time-dependence while sharing as much as it can between
different time steps. This would already be much better than using a different
conditional probability distribution for each ¢, but the network would then have to
extrapolate when faced with new values of t.

To complete our view of an RNN as a graphical model, we must describe how
to draw samples from the model. The main operation that we need to perform is
simply to sample from the conditional distribution at each time step. However,
there is one additional complication. The RNN must have some mechanism for
determining the length of the sequence. This can be achieved in various ways.

In the case when the output is a symbol taken from a vocabulary, one can
add a special symbol corresponding to the end of a sequence (Schmidhuber, 2012).
When that symbol is generated, the sampling process stops. In the training set,
we insert this symbol as an extra member of the sequence, immediately after gl)
in each training example.

Another option is to introduce an extra Bernoulli output to the model that
represents the decision to either continue generation or halt generation at each
time step. This approach is more general than the approach of adding an extra
symbol to the vocabulary, because it may be applied to any RNN, rather than
only RNNs that output a sequence of symbols. For example, it may be applied to
an RNN that emits a sequence of real numbers. The new output unit is usually a
sigmoid unit trained with the cross-entropy loss. In this approach the sigmoid is
trained to maximize the log-probability of the correct prediction as to whether the
sequence ends or continues at each time step.

Another way to determine the sequence length 7 is to add an extra output to
the model that predicts the integer 7 itself. The model can sample a value of +
and then sample 7 steps worth of data. This approach requires adding an extra
input to the recurrent update at each time step so that the recurrent update is
aware of whether it is near the end of the generated sequence. This extra input
can either consist of the value of 7 or can consist of r —t, the number of remaining
time steps. Without this extra input, the RNN might generate sequences that
end abruptly, such as a sentence that ends before it is complete. This approach is
based on the decomposition

P(a™,..., 2) = P(r)P(a™,..., 2 | 7). (10.34)

The strategy of predicting 7 directly is used for example by Goodfellow ez al.
390
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

(2014d).

10.2.4 Modeling Sequences Conditioned on Context with RNNs

In the previous section we described how an RNN could correspond to a directed
graphical model over a sequence of random variables y“) with no inputs 2. Of
course, our development of RNNs as in Eq. 10.8 included a sequence of inputs
x) 2)... ,a(7. In general, RNNs allow the extension of the graphical model
view to represent not only a joint distribution over the y variables but also a
conditional distribution over y given a. As discussed in the context of feedforward
networks in Sec. 6.2.1.1, any model representing a variable P (y; @) can be reinter-
preted as a model representing a conditional distribution P(y|w) with w= 6. We
can extend such a model to represent a distribution P(y | ) by using the same
P(y | w) as before, but making w a function of x. In the case of an RNN, this
can be achieved in different ways. We review here the most common and obvious
choices.

Previously, we have discussed RNNs that take a sequence of vectors x for
#=1,...,7 as input. Another option is to take only a single vector x as input.
When z is a fixed-size vector, we can simply make it an extra input of the RNN
that generates the y sequence. Some common ways of providing an extra input to
an RNN are:

1. as an extra input at each time step, or
2. as the initial state h©, or

3. both.

The first and most common approach is illustrated in Fig. 10.9. The interaction
between the input x and each hidden unit vector h“) is parametrized by a newly
introduced weight matrix R that was absent from the model of only the sequence
of y values. The same product «!'R is added as additional input to the hidden
units at every time step. We can think of the choice of x as determining the value
of « ' R that is effectively a new bias parameter used for each of the hidden units.
The weights remain independent of the input. We can think of this model as taking
the parameters @ of the non-conditional model and turning them into w, where
the bias parameters within w are now a function of the input.

Rather than receiving only a single vector x as input, the RNN may receive a
sequence of vectors #) as input. The RNN described in Eq. 10.8 corresponds to a

391
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

Figure 10.9: An RNN that maps a fixed-length vectorz into a distribution over sequences

Y. This RNN is appropriate for tasks such as image captioning, where a single image is
used as input to a model that then produces a sequence of words describing the image.
Each element y) of the observed output sequence serves both as input (for the current
time step) and, during training, as target (for the previous time step).

392
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

Figure 10.10: A conditional recurrent neural network mapping a variable-length sequence
of 2 values into a distribution over sequences of y values of the same length. Compared
to Fig. 10.3, this RNN contains connections from the previous output to the current state.
These connections allow this RNN to model an arbitrary distribution over sequences ofy

given sequences of z of the same length. The RNN of Fig. 10.3 is only able to represent
distributions in which the y values are conditionally independent from each other given
the a values.

393
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

conditional distribution P(y™, wees y | ge) | vee ,al7)) that makes a conditional
independence assumption that this distribution factorizes as

I] Py® |2®,...,2). (10.35)
t

To remove the conditional independence assumption, we can add connections from
the output at time ¢ to the hidden unit at time ¢+ 1, as shown in Fig. 10.10. The
model can then represent arbitrary probability distributions over the y sequence.
This kind of model representing a distribution over a sequence given another
sequence still has one restriction, which is that the length of both sequences must
be the same. We describe how to remove this restriction in Sec. 10.4.

Figure 10.11: Computation of a typical bidirectional recurrent neural network, meant
to learn to map input sequences z to target: sequences y, with loss L) at each step t.
The h recurrence propagates information forward in time (towards the right) while the
g recurrence propagates information backward in time (towards the left). Thus at each
point t, the output units o can benefit from a relevant summary of the past in itsh
input and from a relevant summary of the future in its g*) input.

394
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

10.3. Bidirectional RNNs

All of the recurrent networks we have considered up to now have a “causal” struc-
ture, meaning that the state at time ¢ only captures information from the past,
aol) wee oF} and the present input a). Some of the models we have discussed
also allow information from past y values to affect the current state when the y
values are available.

However, in many applications we want to output a prediction of y which
may depend on the whole input sequence. For example, in speech recognition,
the correct interpretation of the current sound as a phoneme may depend on the
next few phonemes because of co-articulation and potentially may even depend on
the next few words because of the linguistic dependencies between nearby words: if
there are two interpretations of the current word that are both acoustically plausible,
we may have to look far into the future (and the past) to disambiguate them.
This is also true of handwriting recognition and many other sequence-to-sequence
learning tasks, described in the next section.

Bidirectional recurrent neural networks (or bidirectional RNNs) were invented
to address that need (Schuster and Paliwal, 1997). They have been extremely suc-
cessful (Graves, 2012) in applications where that need arises, such as handwriting
recognition (Graves et al., 2008; Graves and Schmidhuber, 2009), speech recogni-
tion (Graves and Schmidhuber, 2005; Graves et al., 2013) and bioinformatics (Baldi
et al., 1999).

As the name suggests, bidirectional RNNs combine an RNN that moves forward
through time beginning from the start of the sequence with another RNN that
moves backward through time beginning from the end of the sequence. Fig. 10.11
illustrates the typical bidirectional RNN, with ne) standing for the state of the
sub-RNN that moves forward through time and g” standing for the state of the
sub-RNN that moves backward through time. This allows the output units o) to
compute a representation that, depends on both the past and the future but
is most sensitive to the input values around timet, without having to specify a
fixed-size window around t (as one would have to do with a feedforward network,
a convolutional network, or a regular RNN with a fixed-size look-ahead buffer).

This idea can be naturally extended to 2-dimensional input, such as images,
by having four RNNs, each one going in one of the four directions: up, down,
left, right. At each point (i,j) of a 2-D grid, an output O,,; could then compute a
representation that would capture mostly local information but could also depend
on long-range inputs, if the RNN is able to learn to carry that information.
Compared to a convolutional network, RNNs applied to images are typically more

395
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

expensive but allow for long-range lateral interactions between features in the
same feature map (Visin et al., 2015; Kalchbrenner ef al., 2015). Indeed, the
forward propagation equations for such RNNs may be written in a form that shows
they use a convolution that computes the bottom-up input to each layer, prior
to the recurrent propagation across the feature map that incorporates the lateral
interactions.

10.4 Encoder-Decoder Sequence-to-Sequence Architec-
tures

We have seen in Fig. 10.5 how an RNN can map an input sequence to a fixed-size
vector. We have seen in Fig. 10.9 how an RNN can map a fixed-size vector to a
sequence. We have seen in Fig. 10.3, Fig. 10.4, Fig. 10.10 and Fig. 10.11 how an
RNN can map an input sequence to an output sequence of the same length.

Here we discuss how an RNN can be trained to map an input sequence to an
output sequence which is not necessarily of the same length. This comes up in
many applications, such as speech recognition, machine translation or question
answering, where the input and output sequences in the training set are generally
not of the same length (although their lengths might be related).

We often call the input to the RNN the “context.” We want to produce a
representation of this context, C’. The context C' might be a vector or sequence of
vectors that summarize the input sequence X = (af), wey (r=),

The simplest RNN architecture for mapping a variable-length sequence to an-
other variable-length sequence was first proposed by Cho ez? al. (2014a) and shortly
after by Sutskever ef al. (2014), who independently developed that architecture and
were the first to obtain state-of-the-art translation using this approach. The former
system is based on scoring proposals generated by another machine translation
system, while the latter uses a standalone recurrent network to generate the trans-
lations. These authors respectively called this architecture, illustrated in Fig. 10.12,
the encoder-decoder or sequence-to-sequence architecture. The idea is very simple:
(1) an encoder or reader or input RNN processes the input sequence. The encoder
emits the context C, usually as a simple function of its final hidden state. (2) a
decoder or writer or output RNN is conditioned on that fixed-length vector (just like
in Fig. 10.9) to generate the output sequence Y = (y®),...,y()). The innovation
of this kind of architecture over those presented in earlier sections of this chapter is
that the lengths n, and n, can vary from each other, while previous architectures
constrained n, =n, = T. In a sequence-to-sequence architecture, the two RNNs

396
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

Encoder

“nN

t ‘
OrOrne}

N /

~ a7
\

( v v Decoder Y v )
CC i =
ay.
L A A
I
L

Figure 10.12: Example of an encoder-decoder or sequence-to-sequence RNN architecture,
for learning to generate an output sequence fy,...,y‘»)) given an input sequence
(x@) ,x(2),...,x("=)). It is composed of an encoder RNN that reads the input sequence
and a decoder RNN that generates the output sequence (or computes the probability of a
given output sequence). The final hidden state of the encoder RNN is used to compute a
generally fixed-size context variableC which represents a semantic summary of the input
sequence and is given as input to the decoder RNN.

397
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

are trained jointly to maximize the average oflog P (y, wees yr) | gl) veey g{"=))
over all the pairs of 2 and y sequences in the training set. The last state hp, of
the encoder RNN is typically used as a representation C of the input sequence
that is provided as input to the decoder RNN.

If the context C' is a vector, then the decoder RNN is simply a vector-to-
sequence RNN as described in Sec. 10.2.4. As we have seen, there are at least two
ways for a vector-to-sequence RNN to receive input. The input can be provided as
the initial state of the RNN, or the input can be connected to the hidden units at
each time step. These two ways can also be combined.

There is no constraint that the encoder must have the same size of hidden layer
as the decoder.

One clear limitation of this architecture is when the context C' output by the
encoder RNN has a dimension that is too small to properly summarize a long
sequence. This phenomenon was observed by Bahdanau et al. (2015) in the context
of machine translation. They proposed to make C'a variable-length sequence rather
than a fixed-size vector. Additionally, they introduced an attention mechanism
that learns to associate elements of the sequence C’ to elements of the output
sequence. See Sec. 12.4.5.1 for more details.

10.5 Deep Recurrent Networks

The computation in most RNNs can be decomposed into three blocks of parameters
and associated transformations:

1. from the input to the hidden state,
2. from the previous hidden state to the next hidden state, and

3. from the hidden state to the output.

With the RNN architecture of Fig. 10.3, each of these three blocks is associated
with a single weight matrix. In other words, when the network is unfolded, each
of these corresponds to a shallow transformation. By a shallow transformation,
we mean a transformation that would be represented by a single layer within
a deep MLP. Typically this is a transformation represented by a learned affine
transformation followed by a fixed nonlinearity.

Would it be advantageous to introduce depth in each of these operations?
Experimental evidence (Graves et al., 2013; Pascanu et al., 2014a) strongly suggests
so. The experimental evidence is in agreement with the idea that we need enough

398
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

Figure 10.13: A recurrent neural network can be made deep in many ways (Pascanu
et al., 2014a). (a) The hidden recurrent state can be broken down into groups organized
hierarchically. (6) Deeper computation (e.g., an MLP) can be introduced in the input-to-
hidden, hidden-to-hidden and hidden-to-output parts. This may lengthen the shortest
path linking different time steps. (c) The path-lengthening effect can be mitigated by
introducing skip connections.

399
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

depth in order to perform the required mappings. See also Schmidhuber (1992),
El Hihi and Bengio (1996), or Jaeger (2007a) for earlier work on deep RNNs.

Graves et al. (2013) were the first to show a significant benefit of decomposing
the state of an RNN into multiple layers as in Fig. 10.13 (left). We can think
of the lower layers in the hierarchy depicted in Fig. 10.13a as playing a role in
transforming the raw input into a representation that is more appropriate, at
the higher levels of the hidden state. Pascanu et al. (2014a) go a step further
and propose to have a separate MLP (possibly deep) for each of the three blocks
enumerated above, as illustrated in Fig. 10.13b. Considerations of representational
capacity suggest to allocate enough capacity in each of these three steps, but doing
so by adding depth may hurt learning by making optimization difficult. In general,
it is easier to optimize shallower architectures, and adding the extra depth of
Fig. 10.13b makes the shortest path from a variable in time step ¢ to a variable
in time step ¢ + 1 become longer. For example, if an MLP with a single hidden
layer is used for the state-to-state transition, we have doubled the length of the
shortest path between variables in any two different time steps, compared with the
ordinary RNN of Fig. 10.3. However, as argued by Pascanu et al. (2014a), this
can be mitigated by introducing skip connections in the hidden-to-hidden path, as
illustrated in Fig. 10.13c.

10.6 Recursive Neural Networks

Recursive neural networks” represent yet another generalization of recurrent net-
works, with a different kind of computational graph, which is structured as a deep
tree, rather than the chain-like structure of RNNs. The typical computational
graph for a recursive network is illustrated in Fig. 10.14. Recursive neural networks
were introduced by Pollack (1990) and their potential use for learning to reason
was described by by Bottou (2011). Recursive networks have been successfully
applied to processing data structures as input to neural nets (Frasconi ez al.,
1997, 1998), in natural language processing (Socher et al., 2011a,c, 2013a) as well
as in computer vision (Socher ez al., 2011b).

One clear advantage of recursive nets over recurrent nets is that for a sequence
of the same length 7, the depth (measured as the number of compositions of
nonlinear operations) can be drastically reduced from 7 to O(log7), which might
help deal with long-term dependencies. An open question is how to best structure
the tree. One option is to have a tree structure which does not depend on the data,

2We suggest to not abbreviate “recursive neural network” as “RNN” to avoid confusion with
“recurrent neural network.”

400
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

Figure 10.14: A recursive network has a computational graph that generalizes that of the
recurrent network from a chain to a tree. A variable-size sequencea), w |. .., a can
be mapped to a fixed-size representation (the output 0), with a fixed set of parameters

(the weight matrices U, V, W). The figure illustrates a supervised learning case in which
some target y is provided which is associated with the whole sequence.

401
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

such as a balanced binary tree. In some application domains, external methods
can suggest the appropriate tree structure. For example, when processing natural
language sentences, the tree structure for the recursive network can be fixed to
the structure of the parse tree of the sentence provided by a natural language
parser (Socher et al., 2011a, 2013a). Ideally, one would like the learner itself to
discover and infer the tree structure that is appropriate for any given input, as
suggested by Bottou (2011).

Many variants of the recursive net idea are possible. For example, Frasconi
et al. (1997) and Frasconi et al. (1998) associate the data with a tree structure,
and associate the inputs and targets with individual nodes of the tree. The
computation performed by each node does not have to be the traditional artificial
neuron computation (affine transformation of all inputs followed by a monotone
nonlinearity). For example, Socher et al. (2013a) propose using tensor operations
and bilinear forms, which have previously been found useful to model relationships
between concepts (Weston et al., 2010; Bordes et al., 2012) when the concepts are
represented by continuous vectors (embeddings).

10.7 The Challenge of Long-Term Dependencies

The mathematical challenge of learning long-term dependencies in recurrent net-
works was introduced in Sec. 8.2.5. The basic problem is that gradients propagated
over many stages tend to either vanish (most of the time) or explode (rarely, but
with much damage to the optimization). Even if we assume that the parameters are
such that the recurrent network is stable (can store memories, with gradients not
exploding), the difficulty with long-term dependencies arises from the exponentially
smaller weights given to long-term interactions (involving the multiplication of
many Jacobians) compared to short-term ones. Many other sources provide a
deeper treatment (Hochreiter, 1991; Doya, 1993; Bengio e¢ al., 1994; Pascanu et al.,
2013a) . In this section, we describe the problem in more detail. The remaining
sections describe approaches to overcoming the problem.

Recurrent networks involve the composition of the same function multiple
times, once per time step. These compositions can result in extremely nonlinear
behavior, as illustrated in Fig. 10.15.

In particular, the function composition employed by recurrent neural networks
somewhat resembles matrix multiplication. We can think of the recurrence relation

h®© = wihaev (10.36)

as a very simple recurrent neural network lacking a nonlinear activation function,

402
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

Repeated function composition

4
» 3r
3
Bo 2b
8
om IPF
°
a OF
aS}
@ -if
&
ge —2/
py
—3b
—4
—60

Input coordinate

Figure 10.15: When composing many nonlinear functions (like the linearganh layer shown
here), the result is highly nonlinear, typically with most of the values associated with a tiny
derivative, some values with a large derivative, and many alternations between increasing
and decreasing. In this plot, we plot a linear projection of a 100-dimensional hidden state
down to a single dimension, plotted on the yaxis. The z-axis is the coordinate of the
initial state along a random direction in the 100-dimensional space. We can thus view this
plot as a linear cross-section of a high-dimensional function. The plots show the function
after each time step, or equivalently, after each number of times the transition function
has been composed.

403
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

and lacking inputs a. As described in Sec. 8.2.5, this recurrence relation essentially
describes the power method. It may be simplified to

n® = (wt) A, (10.37)
and if W admits an eigendecomposition of the form
W=Qaq', (10.38)
with orthogonal Q, the recurrence may be simplified further to
h® =Q atqn®. (10.39)

The eigenvalues are raised to the power of ¢t causing eigenvalues with magnitude
less than one to decay to zero and eigenvalues with magnitude greater than one to
explode. Any component of h© that is not aligned with the largest eigenvector
will eventually be discarded.

This problem is particular to recurrent networks. In the scalar case, imagine
multiplying a weight w by itself many times. The product w* will either vanish or
explode depending on the magnitude of w. However, if we make a non-recurrent
network that has a different weight w at each time step, the situation is different.
If the initial state is given by 1, then the state at time t is given by |], w), Suppose
that the w” values are generated randomly, independently from one another, with
zero mean and variance v. The variance of the product is O(v"). To obtain some
desired variance v* we may choose the individual weights with variancev = V/v*.
Very deep feedforward networks with carefully chosen scaling can thus avoid the
vanishing and exploding gradient problem, as argued by Sussillo (2014).

The vanishing and exploding gradient problem for RNNs was independently
discovered by separate researchers (Hochreiter, 1991; Bengio et al., 1993, 1994).
One may hope that the problem can be avoided simply by staying in a region of
parameter space where the gradients do not vanish or explode. Unfortunately, in
order to store memories in a way that is robust to small perturbations, the RNN
must enter a region of parameter space where gradients vanish (Bengio et al., 1993,
1994). Specifically, whenever the model is able to represent long term dependencies,
the gradient of a long term interaction has exponentially smaller magnitude than
the gradient of a short term interaction. It does not mean that it is impossible
to learn, but that it might take a very long time to learn long-term dependencies,
because the signal about these dependencies will tend to be hidden by the smallest
fluctuations arising from short-term dependencies. In practice, the experiments
in Bengio et al. (1994) show that as we increase the span of the dependencies that

404
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

need to be captured, gradient-based optimization becomes increasingly difficult,
with the probability of successful training of a traditional RNN via SGD rapidly
reaching 0 for sequences of only length 10 or 20.

For a deeper treatment of recurrent networks as dynamical systems, see Doya
(1993), Bengio et al. (1994) and Siegelmann and Sontag (1995), with a review
in Pascanu et al. (2013a). The remaining sections of this chapter discuss various
approaches that have been proposed to reduce the difficulty of learning long-
term dependencies (in some cases allowing an RNN to learn dependencies across
hundreds of steps), but the problem of learning long-term dependencies remains
one of the main challenges in deep learning.

10.8 Echo State Networks

The recurrent weights mapping from h&-)) toh and the input weights mapping
from z) to h® are some of the most difficult parameters to learn in a recurrent
network. One proposed (Jaeger, 2003; Maass et al., 2002; Jaeger and Haas, 2004;
Jaeger, 2007b) approach to avoiding this difficulty is to set the recurrent weights
such that the recurrent hidden units do a good job of capturing the history of
past inputs, and only learn the output weights. This is the idea that was
independently proposed for echo state networks or ESNs (Jaeger and Haas, 2004;
Jaeger, 2007b) and liquid state machines (Maass et al., 2002). The latter is similar,
except that it uses spiking neurons (with binary outputs) instead of the continuous-
valued hidden units used for ESNs. Both ESNs and liquid state machines are
termed reservoir computing (LukoSevicius and Jaeger, 2009) to denote the fact
that the hidden units form of reservoir of temporal features which may capture
different: aspects of the history of inputs.

One way to think about these reservoir computing recurrent networks is that
they are similar to kernel machines: they map an arbitrary length sequence (the
history of inputs up to time ) into a fixed-length vector (the recurrent state h™),
on which a linear predictor (typically a linear regression) can be applied to solve
the problem of interest. The training criterion may then be easily designed to be
convex as a function of the output weights. For example, if the output consists
of linear regression from the hidden units to the output targets, and the training
criterion is mean squared error, then it is convex and may be solved reliably with
simple learning algorithms (Jaeger, 2003).

The important question is therefore: how do we set the input and recurrent
weights so that a rich set of histories can be represented in the recurrent neural
network state? The answer proposed in the reservoir computing literature is to

405
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

view the recurrent net as a dynamical system, and set the input and recurrent
weights such that the dynamical system is near the edge of stability.

The original idea was to make the eigenvalues of the Jacobian of the state-to-
state transition function be close to 1. As explained in Sec. 8.2.5, an important
characteristic of a recurrent network is the eigenvalue spectrum of the Jacobians
J® = soe . Of particular importance is the spectral radius of J), defined to be
the maximum of the absolute values of its eigenvalues.

To understand the effect of the spectral radius, consider the simple case of
back-propagation with a Jacobian matrix J that does not change with ¢. This
case happens, for example, when the network is purely linear. Suppose that J has
an eigenvector v with corresponding eigenvalue 4. Consider what happens as we
propagate a gradient vector backwards through time. If we begin with a gradient
vector g, then after one step of back-propagation, we will have Jg, and after n
steps we will have J%g. Now consider what happens if we instead back-propagate
a perturbed version of g. If we begin with g + dv, then after one step, we will
have J(g + dv). After n steps, we will have J"(g + dv). From this we can see
that back-propagation starting from g and back-propagation starting from g + dv
diverge by 6J"v after n steps of back-propagation. If v is chosen to be a unit
eigenvector of J with eigenvalue 4, then multiplication by the Jacobian simply
scales the difference at each step. The two executions of back-propagation are
separated by a distance of 6|A|". When v corresponds to the largest value of |A\,
this perturbation achieves the widest possible separation of an initial perturbation
of size 6.

When |A| > 1, the deviation size 6|\|" grows exponentially large. When |A| < 1,
the deviation size becomes exponentially small.

Of course, this example assumed that the Jacobian was the same at every
time step, corresponding to a recurrent network with no nonlinearity. When a
nonlinearity is present, the derivative of the nonlinearity will approach zero on
many time steps, and help to prevent the explosion resulting from a large spectral
radius. Indeed, the most recent work on echo state networks advocates using a
spectral radius much larger than unity (Yildiz et al., 2012; Jaeger, 2012).

Everything we have said about back-propagation via repeated matrix multipli-
cation applies equally to forward propagation in a network with no nonlinearity,
where the state h¢+) = nOTW.

When a linear map W' always shrinks h, as measured by the L? norm, then
we say that the map is contractive. When the spectral radius is less than one, the
mapping from h® to hCt+ is contractive, so a small change becomes smaller after
each time step. This necessarily makes the network forget information about the

406
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

past when we use a finite level of precision (such as 32 bit integers) to store the
state vector.

The Jacobian matrix tells us how a small change of h propagates one step
forward, or equivalently, how the gradient on h“*+) propagates one step backward,
during back-propagation. Note that neither W nor J need to be symmetric (al-
though they are square and real), so they can have complex-valued eigenvalues and
eigenvectors, with imaginary components corresponding to potentially oscillatory
behavior (if the same Jacobian was applied iteratively). Even though h® ora
small variation of h™ of interest in back-propagation are real-valued, they can
be expressed in such a complex-valued basis. What matters is what happens to
the magnitude (complex absolute value) of these possibly complex-valued basis
coefficients, when we multiply the matrix by the vector. An eigenvalue with
magnitude greater than one corresponds to magnification (exponential growth, if
applied iteratively) or shrinking (exponential decay, if applied iteratively).

With a nonlinear map, the Jacobian is free to change at each step. The
dynamics therefore become more complicated. However, it remains true that a
small initial variation can turn into a large variation after several steps. One
difference between the purely linear case and the nonlinear case is that the use of
a squashing nonlinearity such as tanh can cause the recurrent dynamics to become
bounded. Note that it is possible for back-propagation to retain unbounded
dynamics even when forward propagation has bounded dynamics, for example,
when a sequence of tanh units are all in the middle of their linear regime and are
connected by weight matrices with spectral radius greater than 1. However, it is
rare for all of the tanh units to simultaneously lie at their linear activation point.

The strategy of echo state networks is simply to fix the weights to have some
spectral radius such as 3, where information is carried forward through time but
does not explode due to the stabilizing effect of saturating nonlinearities like tanh.

More recently, it has been shown that the techniques used to set the weights
in ESNs could be used to initialize the weights in a fully trainable recurrent net-
work (with the hidden-to-hidden recurrent weights trained using back-propagation
through time), helping to learn long-term dependencies (Sutskever, 2012; Sutskever
et al., 2013). In this setting, an initial spectral radius of 1.2 performs well, combined
with the sparse initialization scheme described in Sec. 8.4.

407
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

10.9 Leaky Units and Other Strategies for Multiple
Time Scales

One way to deal with long-term dependencies is to design a model that operates
at multiple time scales, so that some parts of the model operate at fine-grained
time scales and can handle small details, while other parts operate at coarse time
scales and transfer information from the distant past to the present more efficiently.
Various strategies for building both fine and coarse time scales are possible. These
include the addition of skip connections across time, “leaky units” that integrate
signals with different time constants, and the removal of some of the connections
used to model fine-grained time scales.

10.9.1 Adding Skip Connections through Time

One way to obtain coarse time scales is to add direct connections from variables in
the distant past to variables in the present. The idea of using such skip connections
dates back to Lin ez al. (1996) and follows from the idea of incorporating delays in
feedforward neural networks (Lang and Hinton, 1988). In an ordinary recurrent
network, a recurrent connection goes from a unit at timet to a unit at time t+ 1.
It is possible to construct recurrent networks with longer delays (Bengio, 1991).

As we have seen in Sec. 8.2.5, gradients may vanish or explode exponentially
with respect to the number of time steps. Lin e¢ al. (1996) introduced
recurrent connections with a time-delay of d to mitigate this problem. Gradients
now diminish exponentially as a function of 5 rather than 7. Since there are both
delayed and single step connections, gradients may still explode exponentially in 7.
This allows the learning algorithm to capture longer dependencies although not all
long-term dependencies may be represented well in this way.

10.9.2 Leaky Units and a Spectrum of Different Time Scales

Another way to obtain paths on which the product of derivatives is close to one is to
have units with linear self-connections and a weight near one on these connections.

When we accumulate a running average pl of some value uv) by applying the
update p© + apt) +(1—a) v) the a parameter is an example of a linear self-
connection from p¢—) to pw. When ais near one, the running average remembers
information about the past for a long time, and when a is near zero, information
about the past is rapidly discarded. Hidden units with linear self-connections can
behave similarly to such running averages. Such hidden units are called leaky units.

408
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

Skip connections through d time steps are a way of ensuring that a unit can
always learn to be influenced by a value from d time steps earlier. The use of a
linear self-connection with a weight near one is a different way of ensuring that the
unit can access values from the past. The linear self-connection approach allows
this effect to be adapted more smoothly and flexibly by adjusting the real-valued
a rather than by adjusting the integer-valued skip length.

These ideas were proposed by Mozer (1992) and by El Hihi and Bengio (1996).
Leaky units were also found to be useful in the context of echo state networks
(Jaeger et al., 2007).

There are two basic strategies for setting the time constants used by leaky
units. One strategy is to manually fix them to values that remain constant, for
example by sampling their values from some distribution once at initialization time.
Another strategy is to make the time constants free parameters and learn them.
Having such leaky units at different time scales appears to help with long-term
dependencies (Mozer, 1992; Pascanu et al., 2013a).

10.9.3 Removing Connections

Another approach to handle long-term dependencies is the idea of organizing
the state of the RNN at multiple time-scales (El Hihi and Bengio, 1996), with
information flowing more easily through long distances at the slower time scales.

This idea differs from the skip connections through time discussed earlier
because it involves actively removing length-one connections and replacing them
with longer connections. Units modified in such a way are forced to operate on a
long time scale. Skip connections through time add edges. Units receiving such
new connections may learn to operate on a long time scale but may also choose to
focus on their other short-term connections.

There are different ways in which a group of recurrent units can be forced to
operate at different time scales. One option is to make the recurrent units leaky,
but to have different groups of units associated with different fixed time scales.
This was the proposal in Mozer (1992) and has been successfully used in Pascanu
et al. (2013a). Another option is to have explicit and discrete updates taking place
at different times, with a different frequency for different groups of units. This is
the approach of EF] Hihi and Bengio (1996) and Koutnik et al. (2014). It worked
well on a number of benchmark datasets.

409
CHAPTER 10. SEQUENCE MODELING: RECURRENT AND RECURSIVE NETS

10.10 The Long Short-Term Memory and Other Gated
RNNs

As of this writing, the most effective sequence models used in practical applications
are called gated RNNs. These include the long short-term memory and networks
based on the gated recurrent unit.

Like leaky units, gated RNNs are based on the idea of creating paths through
time that have derivatives that neither vanish nor explode. Leaky units did
this with connection weights that were either manually chosen constants or were
parameters. Gated RNNs generalize this to connection weights that may change
at each time step.

Leaky units allow the network to accumulate information (such as evidence
for a particular feature or category) over a long duration. However, once that
information has been used, it might be useful for the neural network to forget the
old state. For example, if a sequence is made of sub-sequences and we want a leaky
unit to accumulate evidence inside each sub-subsequence, we need a mechanism to
forget the old state by setting it to zero. Instead of manually deciding when to
clear the state, we want the neural network to learn to decide when to do it. This
is what gated RNNs do.

10.10.1 LSTM

The clever idea of introducing self-loops to produce paths where the gradient can
flow for long durations is a core contribution of the initial long short-term memory
(LSTM) model (Hochreiter and Schmidhuber, 1997). A crucial addition has been
to make the weight on this self-loop conditioned on the context, rather than fixed
(Gers et al., 2000). By making the weight of this self-loop gated (controlled by
another hidden unit), the time scale of integration can be changed dynamically. In
this case, we mean that even for an LSTM with fixed parameters, the time scale of
integration can change based on the input sequence, because the time constants
are output by the model itself. The LSTM has been found extremely successful
in many applications, such as unconstrained handwriting recognition (Graves
et al., 2009), speech recognition (Graves et al., 2013; Graves and Jaitly, 2014),
handwriting generation (Graves, 2013), machine translation (Sutskever et al., 2014),
image captioning (Kiros ef al., 2014b; Vinyals et al., 2014b; Xu et al., 2015) and
parsing (Vinyals et al., 2014a).

The LSTM block diagram is illustrated in Fig. 10.16. The corresponding
forward propagation equations are given below, in the case of a shallow recurrent

410
